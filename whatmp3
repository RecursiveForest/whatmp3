#!/usr/bin/env python

##############################################################
# whatmp3 - Convert FLAC to mp3, create what.cd torrent.
# Created by shardz (logik.li), demonstar55, and The_Creator
# Shell-less fork with external config by Deconstrained
##############################################################

import os
import re
import fnmatch
import shutil
from optparse import OptionParser
from ConfigParser import ConfigParser
from subprocess import Popen,PIPE
import threading

VERSION = "3.6-D"

### BEGIN CONFIGURATION ###
# If the 'type' key is specified (should be a callable expression), use it for converting config values.
# Otherwise, the config value is assumed to be a str.
confVars = {
	'output':
		{'comment':'Output folder unless specified. Keyword "cwd" translates to os.getcwd().',
		 'default':'cwd',
		 'type':lambda x: os.getcwd() if x=='cwd' else x},
	'torrent_dir':
		{'comment':'Directory in which to place torrent files. Keyword "output" translates to the same directory as output.',
		 'default':'output'
		 },
	'moveother':{
		'comment':'Do you want to move additional files (.jpg, .log, etc)?',
		'default':'1',
		'type':lambda x: bool(int(x))},
	'zeropad':
		{'comment':'Do you want to zeropad tracknumbers? (1 => 01, 2 => 02 ...)',
		'default':'1',
		 'type':lambda x: bool(int(x))},
	'dither':
		{'comment':'Do you want to dither FLACs to 16/44 before encoding?',
		 'default':'0',
		 'type':lambda x:bool(int(x))},
	'tracker':
		{'comment':'Specify tracker ("http://tracker.what.cd:34000/")',
		 'default':'http://tracker.what.cd:34000/'},
	'passkey':
		{'comment':'Specify torrent passkey',
		 'default':''},
	'max_threads':
		{'comment':'Max number of threads (ex: Normal: 1, Dual-core = 2, Hyperthreaded Dual-core = 4)',
		 'default':'1',
		 'type':int}
	}

def configDeclaration(name):
	global confVars
	return '# %s\n%s = %s\n'%(confVars[name]['comment'],name,confVars[name]['default'])
	
confFile = os.path.expanduser('~/.whatmp3rc')

# Default encoding options
enc_options = {
	'320':	{'enc': 'lame',  	'opts': '-q 0 -b 320 --add-id3v2 --ignore-tag-errors'},
	'V0':	{'enc': 'lame',		'opts': '-q 0 -V 0 --vbr-new --add-id3v2 --ignore-tag-errors'},
	'V2':	{'enc': 'lame',		'opts': '-q 0 -V 2 --vbr-new --add-id3v2 --ignore-tag-errors'},
	'V3':   {'enc': 'lame',		'opts': '-q 0 -V 3 --vbr-new --add-id3v2 --ignore-tag-errors'},
	'Q8':	{'enc': 'oggenc',	'opts': '-q 8'},
	'AAC':	{'enc': 'neroAacEnc',	'opts': '-br 320000'},
	'ALAC':	{'enc': 'avconv',	'opts': '-acodec alac'},
	'FLAC': {'enc': 'flac',		'opts': '--best -s'}
}

### END CONFIGURATION ###

codecs = []

# os.system() and os.popen() have issues with `
def escape_backtick(pattern):
	pattern = re.sub('`', '\`', pattern)
	return pattern

def escape_quote(pattern):
	pattern = re.sub('"', '\\"', pattern)
	return pattern

def escape_percent(pattern):
	pattern = re.sub('%', '%%', pattern)
	return pattern

class Transcode(threading.Thread):
	metaflac_fields = ('TITLE', 'ALBUM', 'ARTIST', 'TRACKNUMBER', 'GENRE', 'COMMENT', 'DATE')

	# Each entry is a tuple, and each item in the tuple is a function specifying how to format
	# each command line tag argument (which should return a flat list; results will extend an
	# argument list that gets passed to Popen).
	tagopt_format = {
		'lame':		tuple(map(lambda x: (lambda y:[x,y]),('--tt','--tl','--ta','--tn','--tg','--tc','--ty'))),
		'oggenc':	tuple(map(lambda x: (lambda y:[x,y]),('-t','-l','-a','-N','-G','-c','-d'))),
		'avconv':	tuple(map(lambda x: (lambda y:['-metadata','%s=%s'%(x,y)]), ('title','album','artist','track','genre','comment','date'))),
		'neroAacEnc':	tuple(map(lambda x: (lambda y:['-meta:%s=%s'%(x,y)]),('title','album','artist','track','genre','comment','year'))),
		'flac':		tuple(map(lambda x: (lambda y:['-T','%s=%s'%(x,y)]),metaflac_fields)),
		}
	
	def __init__(self, filename, flacdir, mp3_dir, codec, options, cv):
		global enc_options
		threading.Thread.__init__(self)
		self.file = filename
		self.flacdir = flacdir
		self.mp3_dir = mp3_dir
		self.codec = codec
		self.encoder = enc_options[codec]['enc']
		self.encoder_opts = enc_options[codec]['opts'].split()
		self.options = options
		self.cv = cv
		self.extension = {
			'lame':		'mp3',
			'oggenc':	'ogg',
			'avconv':	'm4a',
			'neroAacEnc':	'm4a',
			'flac':		'flac'
			}[self.encoder]
		## Input file option 
		self.inopt = {
			'lame':		'-',
			'oggenc':	'-',
			'avconv':	'-i -',
			'neroAacEnc':	'-if -',
			'flac':		'-'
			}[self.encoder].split()
		## Output file option
		self.outopt = {
			'lame':		'',
			'oggenc':	'-o',
			'avconv':	'',
			'neroAacEnc':	'-of',
			'flac':		'-o'
			}[self.encoder].split()
	
	@property
	def tags(self):
		"""The file's tags"""
		if not hasattr(self,'_tags'):
			self._tags = {}
			for tag in self.metaflac_fields:
				tagproc = Popen(['metaflac','--show-tag',tag,self.file],stdout=PIPE,stderr=PIPE)
				self._tags[tag] = re.sub(r'\S+=','',tagproc.communicate()[0].rstrip())
		return self._tags
		
	@property
	def tagopts(self):
		"""Compose the arguments for the tagging software, whether the encoder itself or another program"""
		if not hasattr(self,'_tagopts'):
			_format = self.tagopt_format[self.encoder]
			self._tagopts = []
			fields = enumerate(self.metaflac_fields)
			if self.options.skip_genre: # Omit the GENRE metaflac field
				fields = filter(lambda f:f[1]!='GENRE',fields)
			for (i,field) in fields:
				tag = self.tags[field].strip()
				if tag != '':
					self._tagopts.extend(_format[i](tag))
		return self._tagopts

	def run(self):
		if self.options.zeropad and len(self.tags['TRACKNUMBER']) == 1:
			try: self.tags['TRACKNUMBER'] = '%02d'%int(self.tags['TRACKNUMBER'])
			except ValueError: pass

		mp3_filename = re.sub(re.escape(self.flacdir), self.mp3_dir, self.file)
		mp3_filename = re.sub('\.flac$', '', mp3_filename).rstrip()
		filename = '%s.%s'%(mp3_filename,self.extension)
		if not os.path.exists(os.path.dirname(mp3_filename)):
			os.makedirs(os.path.dirname(mp3_filename))
		self.outopt.append(filename)

		flac_command = ''
		mp3_filename = escape_percent(mp3_filename)	# string % (params) will break on filenames including an unescaped % character

		## The decoding process:
		deproc = ['flac','-dc',self.file]

		## The dithering process:
		diproc = 'sox -t wav - -b 16 -t wav - rate 44100 dither'.split()

		## The encoding process:
		enproc = [self.encoder]
		# Input stream
		enproc.extend(self.inopt)
		# Options
		enproc.extend(self.encoder_opts)
		# Tagging options (exclude encoding programs that can't do tagging on the fly)
		if not self.encoder in ('neroAacEnc',):
			enproc.extend(self.tagopts)
		# Output stream
		enproc.extend(self.outopt)

		## Spawn the transcoding pipeline:
		track = "%s: %s (%s): %s %s"%tuple(map(lambda x: self.tags[x],('ARTIST','ALBUM','DATE','TRACKNUMBER','TITLE')))
		deproc = Popen(deproc,stdout=PIPE,stderr=PIPE)
		print ">>> %s: began %s..."%(self.name,track)
		if self.options.dither:
			diproc = Popen(diproc,stdin=deproc.stdout,stdout=PIPE,stderr=PIPE)
			enproc = Popen(enproc,stdin=diproc.stdout,stdout=PIPE,stderr=PIPE)
		else:
			enproc = Popen(enproc,stdin=deproc.stdout,stdout=PIPE,stderr=PIPE)

		## Wait for encoding to finish
		enproc.wait()

		## Print messages if verboseness is enabled:
		if self.options.verbose:
			print deproc.stderr.read()
			print enproc.stdout.read()
			print enproc.stderr.read()

		## Tag the file with a separate command (if using neroAacEnc)
		if self.encoder == 'neroAacEnc':
			ntproc = ['neroAacTag']
			ntproc.append(filename)
			ntproc.extend(self.tagopts)
			ntproc = Popen(ntproc,stdout=PIPE,stderr=PIPE)
			ntproc.wait()

		print "... %s: completed %s."%(self.name,track)

		self.cv.acquire()
		self.cv.notify_all()
		self.cv.release()

		return 0

def add_enc_option(option, opt, value, parser):
	codecs.append(opt[2:])

def main():
	global confFile,confVars,VERSION
	# Load configuration if available
	if os.path.exists(confFile):
		confP = ConfigParser()
		confFileH = open(confFile,'r')
		confP.readfp(confFileH)
		conf = dict(confP.items('main'))
		confFileH.close()
		missingVars = filter(lambda v: v not in conf.keys(),confVars.keys())
		if len(missingVars) > 0:
			print "Missing configuration variables: %s (as of version %s)"%(','.join(missingVars),VERSION)
			open(confFile,'a').write('\n'.join([configDeclaration(v) for v in missingVars]))
			print "Updated configuration file (%s) with new variables. See to it that they're set properly."%confFile
			exit(0);
		for v in filter(lambda k: 'type' in confVars[k].keys(),conf.keys()): # Convert options
			conf[v] = confVars[v]['type'](conf[v])
		if conf['torrent_dir'] == 'output': conf['torrent_dir'] = conf['output']
	else:
		open(confFile,'w').write('# Configuration file for whatmp3\n[main]\n'+'\n'.join([configDeclaration(var) for var in confVars.keys()]))
		print "Configuration file (%s) missing, so it has been created. Please fill in the necessary details before running."%confFile
		exit(0)

	# Parse options and arguments
	usage_text = "%prog [options] [--320 --V2 --Q8 --AAC ...] /path/to/FLAC"
	info_text = "Depends on flac, metaflac, mktorrent, and optionally oggenc, lame, neroAacEnc, neroAacTag, mp3gain, aacgain, vorbisgain, and sox."
	parser = OptionParser(usage=usage_text, version="%prog " + VERSION, epilog=info_text)
	parser.add_option('-v', '--verbose',	action='store_true',	dest='verbose',			default=False,			help='increase verbosity (Default: False)')
	parser.add_option('-n', '--notorrent',	action='store_true',	dest='notorrent',		default=False,			help='will not create a torrent after conversion (Default: False)')
	parser.add_option('--nolog',		action='store_true',	dest='nolog',			default=False,			help='will not move log files after conversion (Default: False)')
	parser.add_option('--nocue',		action='store_true',	dest='nocue',			default=False,			help='will not move cue files after conversion (Default: False)')
	parser.add_option('--nodate',           action='store_true',    dest='nodate',          	default=False,  		help='do not write the creation date to the .torrent file (Default: False)')
	parser.add_option('--skipgenre',        action='store_true',    dest='skip_genre',      	default=False,  		help='do not insert a genre tag in MP3 files (Default: False)')
	parser.add_option('-m', '--moveother',	action='store_true',	dest='moveother',		default=conf['moveother'],	help='move additional files (Default: %s)'%bool(int(conf['moveother'])))
	parser.add_option('-p', '--passkey',	dest='passkey',		default=conf['passkey'],	help='tracker PASSKEY', 	metavar='PASSKEY')
	parser.add_option('-t', '--tracker',	dest='tracker',		default=conf['tracker'],	help='tracker URL (Default: "%s")'%conf['tracker'], metavar='URL')
	parser.add_option('-o', '--output',	dest='output',		default=conf['output'],		help='set the output PATH', 	metavar='PATH')
	parser.add_option('--torrent-dir',	dest='torrent_dir',	default=conf['torrent_dir'],	help='set independent torrent output directory')
	parser.add_option('-z', '--zeropad',	action='store_true',	dest='zeropad',			default=conf['zeropad'],	help='zeropad track numbers (Default: %s)'%bool(int(conf['zeropad'])))
	parser.add_option('-r', '--replaygain',	action='store_true',	dest='replaygain',		default=False,			help='add ReplayGain to new files (Default: False)')
	parser.add_option('-d', '--dither',	action='store_true',	dest='dither',			default=conf['dither'],		help='dither FLACs to 16/44 before encoding (Default: %s)'%bool(int(conf['dither'])))
	parser.add_option('--threads',		type="int",		dest='max_threads',		default=conf['max_threads'],	help='set number of threads THREADS (Default: %d)'%int(conf['max_threads']), metavar='THREADS')
	parser.add_option('-c', '--original',	action='store_true',	dest='original',		default=False,			help='create a torrent for the original FLAC')

	for enc_opt in enc_options.keys():
		parser.add_option("--" + enc_opt, action="callback", callback=add_enc_option, help='convert to %s' % (enc_opt))

	(options, flacdirs) = parser.parse_args()

	if len(flacdirs) < 1:
		parser.error("Incorrect number of arguments")

	if not options.output.endswith('/'):
		options.output += '/'

	if len(codecs) == 0 and not options.original:
		print('You need to provide at least one format to transcode to (320, V0, Q8 ...)')
		exit()

	for flacdir in flacdirs:
		flacdir = os.path.abspath(flacdir)
		flacfiles = []

		for dirpath, dirs, files in os.walk(flacdir, topdown=False):
			for name in files:
				if fnmatch.fnmatch(name, '*.flac') or fnmatch.fnmatch(name, '*.FLAC'):
					flacfiles.append(os.path.join(dirpath, name))
		if options.original:
			print('Working with FLAC...')

			if options.output and options.passkey and options.tracker and not options.notorrent:
				if options.verbose: print('Creating torrent...')
				torrent_command = 'mktorrent -p -a %s/announce -o "%s.torrent" "%s"' % (options.tracker + options.passkey, escape_quote(options.output + os.path.basename(flacdir)), escape_quote(flacdir))
				if options.nodate:
					torrent_command += ' -d'
				if options.verbose: print(escape_backtick(torrent_command))
				os.system(escape_backtick(torrent_command))

			print('Finished working with FLAC')

		for codec in codecs:
			mp3_dir = options.output + os.path.basename(flacdir)
			if 'FLAC' in flacdir:
				mp3_dir = re.sub(re.compile('FLAC', re.I), codec, mp3_dir)
			else:
				mp3_dir = mp3_dir + " (" + codec + ")"
			if not os.path.exists(mp3_dir):
				os.makedirs(mp3_dir)

			print('Encoding with ' + codec + ' started...')

			threads = []
			cv = threading.Condition()
			for filename in flacfiles:
				cv.acquire()
				while((threading.activeCount() == options.max_threads + 1) or (options.max_threads == 0 and threading.activeCount() == 2)):
					cv.wait()
				cv.release()
				t=Transcode(filename, flacdir, mp3_dir, codec, options, cv)
				t.start()
				threads.append(t)

			for t in threads:
				t.join()

			print('\nEncoding with ' + codec + ' finished.')

			if options.moveother:
				if options.verbose: print('Moving other files...')
				for dirpath, dirs, files in os.walk(flacdir, topdown=False):
					for name in files:
						if options.nolog and fnmatch.fnmatch(name, '*.log'):
							continue
						if options.nocue and fnmatch.fnmatch(name, '*.cue'):
							continue
						if not fnmatch.fnmatch(name, '*.flac') and not fnmatch.fnmatch(name, '*.m3u'):
							d = re.sub(re.escape(flacdir), mp3_dir, dirpath)
							if not os.path.exists(d):
								os.makedirs(d)
							shutil.copy(os.path.join(dirpath, name), d)

			if options.replaygain and enc_options[codec]['enc'] != 'flac':
				if options.verbose: print('Applying replay gain...')

				for dirpath, dirs, files in os.walk(mp3_dir, topdown=False):
					for name in dirs:
						if enc_options[codec]['enc'] == 'lame':
							os.system(escape_backtick('mp3gain -q -c -s i "' + os.path.join(dirpath, name) + '"/*.mp3'))
						if enc_options[codec]['enc'] == 'oggenc':
							os.system(escape_backtick('vorbisgain -qafrs "' + os.path.join(dirpath, name) + '"/*.ogg'))
						if enc_options[codec]['enc'] == 'neroAacEnc':
							os.system(escape_backtick('aacgain -q -c "' + os.path.join(dirpath, name) + '"/*.m4a'))

			if options.output and options.passkey and options.tracker and not options.notorrent:
				if options.verbose: print('Creating torrent...')
				torrent_command = 'mktorrent -p -a %s/announce -o "%s.torrent" "%s"' % (options.tracker + options.passkey, escape_backtick(os.path.join(options.torrent_dir, os.path.basename(mp3_dir))), mp3_dir)
				if options.nodate:
					torrent_command += ' -d'
				if options.verbose: print(escape_backtick(torrent_command))
				os.system(escape_backtick(torrent_command))

		if options.verbose: print('All done with ' + flacdir + ' ...')
	return 0

if __name__ == '__main__':
	main()

